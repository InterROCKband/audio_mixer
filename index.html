<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mixer InterROCK — Multi-track com Seleção</title>
<style>
  :root{--bg:#121217;--card:#1c1c24;--muted:#555;--accent:#e06c75;--text:#e6eef6}
  body{margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#0d0d11 0,#14141a 100%);color:var(--text);padding:22px}
  .container{max-width:980px;margin:0 auto}
  h1{margin:0 0 10px;font-size:1.6rem}
  .top{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  select{padding:8px;border-radius:6px;border:0;background:#2a2a33;color:var(--text)}
  .player-card{background:var(--card);padding:14px;border-radius:10px;margin-top:16px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  .tracks{display:flex;flex-direction:column;gap:8px;margin-top:10px}
  .track{display:flex;gap:10px;align-items:center;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .track .name{width:160px;font-weight:600}
  .track .controls{display:flex;gap:8px;align-items:center}
  input[type=range]{-webkit-appearance:none;height:6px;border-radius:6px;background:linear-gradient(90deg,#4a90e2,#50e3c2);outline:none}
  button{background:#2b2b34;color:var(--text);border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
  button.small{padding:6px 8px;font-size:0.9rem}
  button.toggle{background:#34343b}
  button.active{background:var(--accent);color:#fff}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .global-controls{display:flex;gap:8px;align-items:center;margin-top:12px}
  .timebar{width:100%}
  .meta{font-size:0.85rem;color:var(--muted);margin-top:6px}
  footer{margin-top:18px;color:var(--muted);font-size:0.85rem}
  @media (max-width:640px){ .track .name{width:110px} }
</style>
</head>
<body>
<div class="container">
  <h1>Mixer InterROCK</h1>
  <div class="top">
    <label for="songSelect">Música: </label>
    <select id="songSelect"></select>
    <div class="meta" id="songMeta"></div>
  </div>

  <div class="player-card" id="playerCard" style="display:none">
    <div class="row global-controls">
      <button id="playBtn">▶ Play</button>
      <button id="pauseBtn">⏸ Pause</button>
      <button id="stopBtn">⏹ Stop</button>
      <div style="flex:1"></div>
      <div style="display:flex;gap:8px;align-items:center">
        <span style="font-size:0.9rem;color:var(--muted)">Posição</span>
        <input id="globalTime" class="timebar" type="range" min="0" max="1" step="0.01" value="0">
        <span id="timeLabel" style="width:90px;text-align:right;font-size:0.9rem;color:var(--muted)">00:00 / 00:00</span>
      </div>
    </div>

    <div class="tracks" id="tracksContainer"></div>
  </div>

  <footer>
    <strong>Como usar:</strong> escolha a música, ajuste volumes, use MUTE para silenciar e SOLO para isolar. O Stop reinicia a reprodução.
  </footer>
</div>

<script>
/*
  Defina aqui suas músicas e tracks.
  Cada música é um array de objetos: { name: "Nome da Track", file: "tracks/arquivo.mp3" }
  Coloque seus mp3 na pasta /tracks no repositório do GitHub Pages.
*/
const songs = {
  "Jet - Are you gonna be my girl": [
    { name: "Vocais", file: "tracks/AYGBMG/VOCALS.mp3" },
    { name: "Baixo", file: "tracks/AYGBMG/BASS.mp3" },
    { name: "Bateria", file: "tracks/AYGBMG/DRUMS.mp3" },
    { name: "Guitarra Solo", file: "tracks/AYGBMG/LEAD_GUITAR.mp3" },
    { name: "Guitarra Base", file: "tracks/AYGBMG/RHYTHM_GUITAR.mp3" }
  ],
  "Jet - Cold Hard Bitch": [
    { name: "Vocais", file: "tracks/CHB/VOCALS.mp3" },
    { name: "Baixo", file: "tracks/CHB/BASS.mp3" },
    { name: "Bateria", file: "tracks/CHB/DRUMS.mp3" },
    { name: "Guitarra Solo", file: "tracks/CHB/GUITAR_LEAD.mp3" },
    { name: "Guitarra Base", file: "tracks/CHB/GUITAR_RHYTHM.mp3" },
    { name: "Metronomo", file: "tracks/CHB/METR.mp3" }
  ]
};

/* --- Variáveis de estado --- */
let currentSongName = null;
let audioList = []; // {audio, name, mute, solo}
let updateTimer = null;

/* Elementos DOM */
const songSelect = document.getElementById('songSelect');
const tracksContainer = document.getElementById('tracksContainer');
const playerCard = document.getElementById('playerCard');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const stopBtn = document.getElementById('stopBtn');
const globalTime = document.getElementById('globalTime');
const timeLabel = document.getElementById('timeLabel');
const songMeta = document.getElementById('songMeta');

/* Popular select com nomes */
function populateSongList(){
  Object.keys(songs).forEach((name, idx)=>{
    const opt = document.createElement('option');
    opt.value = name;
    opt.textContent = name;
    songSelect.appendChild(opt);
  });
}
populateSongList();

/* Quando o usuário troca a música */
songSelect.addEventListener('change', ()=>{
  const name = songSelect.value;
  loadSong(name);
});

/* Carrega uma música: cria os audio elements e UI */
function loadSong(name){
  stopAndCleanup(); // se já havia algo, interrompe e limpa
  currentSongName = name;
  const trackDefs = songs[name] || [];
  audioList = [];

  // criar audios
  trackDefs.forEach((t, idx)=>{
    const audio = new Audio(t.file);
    audio.preload = "auto";
    audio.crossOrigin = "anonymous";
    audioList.push({audio, name: t.name, mute:false, solo:false});
  });

  // Montar interface
  renderTracksUI();
  playerCard.style.display = audioList.length ? 'block':'none';
  songMeta.textContent = audioList.length ? `${audioList.length} pistas` : '';
  // espera por metadata para ajustar duração (alguns navegadores carregam rápido)
  Promise.all(audioList.map(a => new Promise(resolve => {
    a.audio.addEventListener('loadedmetadata', () => resolve());
    // fallback caso já carregado
    setTimeout(resolve, 1200);
  }))).then(()=>updateGlobalDuration());
}

/* Renderiza as linhas de track com slider, mute e solo */
function renderTracksUI(){
  tracksContainer.innerHTML = '';
  audioList.forEach((item, idx)=>{
    const row = document.createElement('div');
    row.className = 'track';
    row.dataset.index = idx;

    const nameDiv = document.createElement('div');
    nameDiv.className = 'name';
    nameDiv.textContent = item.name;

    const volInput = document.createElement('input');
    volInput.type = 'range';
    volInput.min = 0; volInput.max = 1; volInput.step = 0.01; volInput.value = 1;
    volInput.style.width = '260px';
    volInput.addEventListener('input', (e)=>{
      item.audio.volume = parseFloat(e.target.value);
      // se estava mute/solo, manter estado visual
    });

    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'controls';

    const muteBtn = document.createElement('button');
    muteBtn.className = 'small toggle';
    muteBtn.textContent = 'MUTE';
    muteBtn.addEventListener('click', ()=>{
      item.mute = !item.mute;
      updateMuteSoloStates();
      muteBtn.classList.toggle('active', item.mute);
    });

    const soloBtn = document.createElement('button');
    soloBtn.className = 'small toggle';
    soloBtn.textContent = 'SOLO';
    soloBtn.addEventListener('click', ()=>{
      item.solo = !item.solo;
      updateMuteSoloStates();
      soloBtn.classList.toggle('active', item.solo);
    });

    controlsDiv.appendChild(muteBtn);
    controlsDiv.appendChild(soloBtn);

    row.appendChild(nameDiv);
    row.appendChild(volInput);
    row.appendChild(controlsDiv);
    tracksContainer.appendChild(row);
  });
}

/* Atualiza os estados de mute/solo entre tracks */
function updateMuteSoloStates(){
  const anySolo = audioList.some(a => a.solo);
  audioList.forEach((item, idx)=>{
    if(anySolo){
      // se há solo(s) ativados, somente tracks com solo ficam audíveis
      item.audio.muted = !item.solo;
    } else {
      // caso não haja solo, aplica o mute individual
      item.audio.muted = !!item.mute;
    }
    // garantia: se both solo and mute true on same track -> solo wins (should be audible)
    if(item.solo) item.audio.muted = false;
  });
}

/* Play / Pause / Stop (para todos os audios) */
playBtn.addEventListener('click', playAll);
pauseBtn.addEventListener('click', pauseAll);
stopBtn.addEventListener('click', stopAll);

function playAll(){
  if(!audioList.length) return;
  // sincronizar starts: pega o currentTime baseado no primeiro audio
  const t = audioList[0].audio.currentTime || 0;
  audioList.forEach(a => {
    try{
      // cada audio recebe o mesmo currentTime
      a.audio.currentTime = Math.min(t, a.audio.duration || t);
      a.audio.play().catch(()=>{/* autoplay blocked until user interaction - user pressed button so should be fine */});
    }catch(e){}
  });
  updateMuteSoloStates();
  startTimer();
}

function pauseAll(){
  audioList.forEach(a => a.audio.pause());
  stopTimer();
}

function stopAll(){
  audioList.forEach(a => {
    a.audio.pause();
    try{ a.audio.currentTime = 0; }catch(e){}
  });
  updateGlobalTimeUI();
  stopTimer();
}

function stopAndCleanup(){
  stopTimer();
  audioList.forEach(a=>{
    try{ a.audio.pause(); }catch(e){}
  });
  audioList = [];
  tracksContainer.innerHTML = '';
  playerCard.style.display = 'none';
  songMeta.textContent = '';
}

/* Timer para atualizar global timebar e label */
function startTimer(){
  if(updateTimer) return;
  updateTimer = setInterval(updateGlobalTimeUI, 200);
}
function stopTimer(){
  if(updateTimer){ clearInterval(updateTimer); updateTimer = null; }
}

/* Atualiza o slider global (max/duration) */
function updateGlobalDuration(){
  // tenta usar a maior duração encontrada entre as tracks
  const durations = audioList.map(a => (isFinite(a.audio.duration) ? a.audio.duration : 0));
  const maxDur = Math.max(...durations, 0);
  globalTime.max = maxDur || 1;
  updateGlobalTimeUI();
}

/* Atualiza posição do slider com base no 1º audio (ou média) */
function updateGlobalTimeUI(){
  if(!audioList.length){ globalTime.value = 0; timeLabel.textContent = '00:00 / 00:00'; return; }
  const ref = audioList[0].audio;
  const cur = ref.currentTime || 0;
  const dur = isFinite(ref.duration) ? ref.duration : Math.max(...audioList.map(a=>a.audio.duration||0)) || 0;
  globalTime.value = cur;
  timeLabel.textContent = formatTime(cur) + ' / ' + (dur ? formatTime(dur) : '00:00');
}

/* Quando usuário seeka no slider global */
globalTime.addEventListener('input', (e)=>{
  const v = parseFloat(e.target.value);
  audioList.forEach(a=>{
    try{ a.audio.currentTime = Math.min(v, a.audio.duration || v); }catch(e){}
  });
  updateGlobalTimeUI();
});

/* Stop (reinicio) */
function stopAllImmediate(){
  audioList.forEach(a=>{ a.audio.pause(); try{a.audio.currentTime=0;}catch(e){}; });
  updateGlobalTimeUI();
}

/* util: formatar tempo */
function formatTime(s){
  if(!isFinite(s) || isNaN(s)) return '00:00';
  const mm = Math.floor(s/60).toString().padStart(2,'0');
  const ss = Math.floor(s%60).toString().padStart(2,'0');
  return `${mm}:${ss}`;
}

/* inicializa primeira música automática (se houver) */
if(Object.keys(songs).length){
  songSelect.value = Object.keys(songs)[0];
  loadSong(songSelect.value);
}

/* Opcional: antes de descarregar a página, pausa audios */
window.addEventListener('beforeunload', ()=>{ audioList.forEach(a=>a.audio.pause()); });

</script>
</body>
</html>
